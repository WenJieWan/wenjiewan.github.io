package data;

public class DynamicProgramming {

	public static void main(String[] args) {
		//构建工程数量与资源数量对应的利润关系表
		int m,n;//m代表总额度，n代表总工程数
		n=3;//n=1,2,3...代表工程1，2，3
		m=8;//m=0,1,2,3...代表分配额度0，1，2，3
		//由于数组都是从0开始，为了方便观察，所以第一行我们不用，需要n+1分配空间，额度为0需要考虑所以m+1
		int[][] g=new int[n+1][m+1];//g[i][j]代表第i个工程被分配j资源对应的利润表
		int[][] f=new int[n+1][m+1];//f[i][j]储存的数值代表前i项工程分配了j资源的最大利润值
		int[][] d=new int[n+1][m+1];//d[i][j]储存的是f[i][j]已经求出的情况下对应的第i项的资源分配额度。
		int[] q=new int[n+1];//q[i]代表第i个工程被分配的资源额度，也就是说q数组保存最优解对应的每项工程的分配额度
		//初始化工程对应资源的利润数据
		//这里我就偷个懒，不根据初始化好的大小进行一个个录入了，直接就重新赋值初始了
		g=new int[][]{{0,0,0,0,0,0,0,0,0},
			{0,5,15,40,80,90,95,98,100},
			{0,5,15,40,60,70,73,74,75},
			{0,4,26,40,50,51,52,53,54}};
		
		DynamicProgramming dp = new DynamicProgramming();
		//设置要求的分配额度下的最优解情况
		int num=7;
		//开始动态规划运算
		dp.invest(num, n, g, f, d, q);
	}
	
	public  void  invest(int m,int n,int[][] g,int[][] f,int[][] d,int[] q){
		//首先必须先对第一个工程的最大利润数值进行初始化
		for(int j=0;j<=m;j++){
			//如果不初始化，进行第二项工程演算的时候会出错，第一项工程都为0就没法算最优解了
			f[1][j]=g[1][j];
			//一样，对d数组记录第一项工程分配额度进行保存
			d[1][j]=j;
		}
		//开始从第二项工程进行计算最优解
		for(int i=2;i<=n;i++){
			//自底向上遍历所有分配情况
			for(int j=0;j<=m;j++){
				f[i][j]=0;//初始化第i项分配j资源的最大利润值
				//遍历前一项工程的分配K的组合利润值
				for(int k=0;k<=j;k++){
					int sum=f[i-1][j-k]+g[i][k];//计算前一项工程(j-k)资源是最大利润+本项K资源的数值
					if(sum>f[i][j]){//保留最大情况
						f[i][j]=sum;//赋值最大利润值
						d[i][j]=k;//记录分配值
					}
				}
			}
		}
		/*到这里每次递增算工程的时候，前i项工程的最优解已被算出，重复这个循环过程知道i达到n，
		那么总体最优解就算好了，只不过这个最优解的组合情况为被提取出来，只是保存在d数组中需要下面的往回寻找来筛选出来。
		*/
		//开始构建最优解
		int s=m;//初始化s为m分配数
		q[n]=d[n][m];//q[n]保存计算到最后一个工程的最优分配额，这个应该毋庸置疑的
		for(int i=n-1;i>0;i--){ //初始化i=n-1,从倒数第二项往前遍历查找最优解
			s = s-q[i+1];	//前一项最优解的分配总额度
			q[i] = d[i][s]; //记录当前工程被分配的资源数
		}
		//到此最优解已构建完成，输出q数组即可
		System.out.println("最大利润值为："+f[n][m]);
		System.out.println("最优解情况：");
		for(int i=1;i<=n;i++){
			System.out.println("第"+i+"工程分配资源数为："+q[i]);
		}
	}
}
